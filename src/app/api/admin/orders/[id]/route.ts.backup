import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { auditLog } from '@/lib/audit'
import { notificationService } from '@/lib/notification'
import { OrderStatus, PaymentStatus } from '@/types'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth()
    
    if (!session?.user || !['ADMIN', 'STAFF'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { id } = await params
    const order = await prisma.order.findUnique({
      where: {
        id
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        orderItems: {
          include: {
            bundle: {
              select: {
                id: true,
                name: true,
                price: true,
                image: true,
                category: {
                  select: {
                    id: true,
                    name: true,
                    store: {
                      select: {
                        id: true,
                        name: true
                      }
                    }
                  }
                }
              }
            }
          }
        },
        bank: {
          select: {
            id: true,
            name: true,
            accountNumber: true,
            accountName: true
          }
        },
        payment: {
          select: {
            id: true,
            status: true,
            method: true,
            proofUrl: true,
            createdAt: true,
            updatedAt: true
          }
        }
      }
    })

    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      id: order.id,
      orderNumber: order.orderNumber,
      customer: {
        id: order.user.id,
        name: order.user.name,
        email: order.user.email,
        phone: order.user.phone
      },
      items: order.orderItems.map(item => ({
        id: item.id,
        bundle: {
          id: item.bundle.id,
          name: item.bundle.name,
          price: item.bundle.price,
          image: item.bundle.image,
          category: {
            id: item.bundle.category.id,
            name: item.bundle.category.name,
            store: {
              id: item.bundle.category.store.id,
              name: item.bundle.category.store.name
            }
          }
        },
        quantity: item.quantity,
        price: item.price
      })),
      totalAmount: order.totalAmount,
      orderStatus: order.orderStatus,
      paymentStatus: order.payment?.status || 'PENDING',
      paymentMethod: order.payment?.method || null,
      paymentProof: order.payment?.proofUrl || null,
      notes: order.notes,
      bank: order.bank,
      createdAt: order.createdAt,
      updatedAt: order.updatedAt
    })
  } catch (error) {
    console.error('Error fetching order:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth()
    
    if (!session?.user || !['ADMIN', 'STAFF'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { id } = await params
    const body = await request.json()
    const { orderStatus, paymentStatus, notes } = body

    // Validate order status
    const validOrderStatuses = ['PENDING', 'CONFIRMED', 'READY', 'COMPLETED', 'CANCELLED']
    if (orderStatus && !validOrderStatuses.includes(orderStatus)) {
      return NextResponse.json(
        { error: 'Invalid order status' },
        { status: 400 }
      )
    }

    // Validate payment status
    const validPaymentStatuses = ['PENDING', 'PAID', 'FAILED', 'REFUNDED']
    if (paymentStatus && !validPaymentStatuses.includes(paymentStatus)) {
      return NextResponse.json(
        { error: 'Invalid payment status' },
        { status: 400 }
      )
    }

    // Check if order exists and get current payment status
    const existingOrder = await prisma.order.findUnique({
      where: {
        id
      },
      include: {
        payment: {
          select: {
            id: true,
            status: true,
            method: true,
            proofUrl: true
          }
        }
      }
    })

    if (!existingOrder) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }

    // Prepare update data for order
    const updateData: any = {
      updatedAt: new Date()
    }

    if (orderStatus !== undefined) {
      updateData.orderStatus = orderStatus
    }

    if (notes !== undefined) {
      updateData.notes = notes
    }

    // Update order
    const updatedOrder = await prisma.order.update({
      where: {
        id
      },
      data: updateData,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        orderItems: {
          include: {
            bundle: {
              select: {
                id: true,
                name: true,
                price: true,
                image: true,
                category: {
                  select: {
                    id: true,
                    name: true,
                    store: {
                      select: {
                        id: true,
                        name: true
                      }
                    }
                  }
                }
              }
            }
          }
        },
        bank: {
          select: {
            id: true,
            name: true,
            accountNumber: true,
            accountName: true
          }
        },
        payment: {
          select: {
            id: true,
            status: true,
            method: true,
            proofUrl: true,
            createdAt: true,
            updatedAt: true
          }
        }
      }
    })

    // Handle payment status changes
    if (paymentStatus && paymentStatus !== existingOrder.payment?.status) {
      if (existingOrder.payment) {
        // Update existing payment
        await prisma.payment.update({
          where: {
            id: existingOrder.payment.id
          },
          data: {
            status: paymentStatus as PaymentStatus,
            updatedAt: new Date()
          }
        })
      } else {
        // Create new payment record
        await prisma.payment.create({
          data: {
            orderId: id,
            amount: existingOrder.totalAmount,
            method: 'BANK_TRANSFER', // Default method
            status: paymentStatus as PaymentStatus,
            notes: `Payment status set to ${paymentStatus} by admin ${session.user.email}`
          }
        })
      }
    }

    // Log the status change for audit purposes
    console.log(`Order ${updatedOrder.orderNumber} updated by admin ${session.user.email}:`, {
      orderStatus: orderStatus || existingOrder.orderStatus,
      paymentStatus: paymentStatus || existingOrder.payment?.status || 'PENDING',
      notes: notes || existingOrder.notes
    })

    // Audit logging
    await auditLog.updateOrder(session.user.id, id, {
      orderStatus: orderStatus || existingOrder.orderStatus,
      paymentStatus: paymentStatus || existingOrder.payment?.status || 'PENDING',
      notes: notes || existingOrder.notes
    })

    // Send notifications for status changes
    try {
      if (orderStatus && orderStatus !== existingOrder.orderStatus) {
        console.log(`🔔 Sending order status change notification: ${existingOrder.orderStatus} → ${orderStatus}`)
        await notificationService.notifyOrderStatusChange(id, existingOrder.orderStatus, orderStatus)
      }
      
      if (paymentStatus && paymentStatus !== existingOrder.payment?.status) {
        if (paymentStatus === 'PAID') {
          // Get the updated payment record
          const updatedPayment = await prisma.payment.findFirst({
            where: { orderId: id }
          })
          
          if (updatedPayment) {
            console.log(`🔔 Sending payment confirmed notification for payment: ${updatedPayment.id}`)
            await notificationService.notifyPaymentConfirmed(updatedPayment.id)
          }
        }
      }
    } catch (notificationError) {
      console.error('❌ Error sending notifications:', notificationError)
      // Don't fail the whole operation if notifications fail
    }

    return NextResponse.json({
      id: updatedOrder.id,
      orderNumber: updatedOrder.orderNumber,
      customer: {
        id: updatedOrder.user.id,
        name: updatedOrder.user.name,
        email: updatedOrder.user.email,
        phone: updatedOrder.user.phone
      },
      items: updatedOrder.orderItems.map(item => ({
        id: item.id,
        bundle: {
          id: item.bundle.id,
          name: item.bundle.name,
          price: item.bundle.price,
          image: item.bundle.image,
          category: {
            id: item.bundle.category.id,
            name: item.bundle.category.name,
            store: {
              id: item.bundle.category.store.id,
              name: item.bundle.category.store.name
            }
          }
        },
        quantity: item.quantity,
        price: item.price
      })),
      totalAmount: updatedOrder.totalAmount,
      orderStatus: updatedOrder.orderStatus,
      paymentStatus: updatedOrder.payment?.status || 'PENDING',
      paymentMethod: updatedOrder.payment?.method || null,
      paymentProof: updatedOrder.payment?.proofUrl || null,
      notes: updatedOrder.notes,
      bank: updatedOrder.bank,
      createdAt: updatedOrder.createdAt,
      updatedAt: updatedOrder.updatedAt
    })
  } catch (error) {
    console.error('Error updating order:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
